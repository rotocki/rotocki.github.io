First steps with Pelican to set up this GitHub Page
###################################################

:date: 2019-07-14 16:20
:tags: pelican
:category: Blog
:slug: first-steps-with-pelican-to-set-up-this-github-page
:summary: My first steps to have this GitHub page set up using Pelican

.. contents::

Making first steps in a virtual environment
*******************************************

I've done a little bit of reading to see if it is possible to setup
my own GitHub page without having to resort to Ruby/Jekyll since
I'm much more comfortable with doing stuff in Python.

As I'm trying to use a bit more restructuredText to eventually write 
all of my documentation for Python code in a syntax that is Sphinx-friendly,
I wanted to have that option to write the content in rst files instead of
plain HTML.

Given the assumptions above, I decided to use Pelican and see how far
will I get with it. First step was to install it and see how many other
plugins and/or dependencies will I need to get the job done.

The first thing to do is to install all the dependencies in a virtual
environment so that if this experiment fails, I can just remove
the folder with the environment in it instead of going through
dependencies in my system and cleaning them one by one.

As I've been installing a typical virtual environment, an idea came to my mind.
I was about to create a project which focuses on doing one thing only while being run
always in the same environment is the ideal definition of an application.
Since there is a great tool to keep all dependencies for an application
in a controlled fashion, I thought about managing it using `pipenv` instead.
I've used it in the past for a bit but never really committed to it.
Because this idea sounded like a good one, I decided to run with it:

.. code-block:: shell

    pip install pipenv
    pipenv install pelican


Creating the project and figuring out its structure
***************************************************

After installing Pelican in the virtual environment, I checked how to start
the project rolling. Fortunately, there is a quickstart step similar to the one
you can find in Sphinx.

.. code-block:: shell

    pipenv run pelican-quickstart

I've configured the project in such a way that I customized the title,
author and made sure that it correctly refers to my GitHub page.

Once the quickstart was done, I looked at the structure of the project.
I created a simple **About me** page under ``content/pages/about.rst``
and this blog post under ``content/blog/first-steps-with-pelican-to-set-up-this-github-page.rst``.
I followed the typical `File metadata`_ structure for the blog post 
and a simplified version for **About me** page.

After that everything should be simple, right?

.. code-block:: shell

    pipenv run pelican

I've looked at the generated HTML files stored in output folder in project's default path.
To my surprise, opening just the `index.html` file wasn't as pleasant as I expected,
since all of the other static content like CSS were not collected by the browser.
Opening checking the documentation, I've noticed that I was supposed to serve the pages
on web server instead of just browsing them directly. Sounds logical. The immediate
suggestion was to do it by moving to output directory and running HTTP server
from Python 3's standard library:

.. code-block:: shell

    /content $ python -m http.server

After that, I just opened my browser and checked the page served as ``localhost:8000``


Simplifying serving procedure with invoke and its tasks
*******************************************************

The page worked correctly but I was not satisfied with this approach as it seemed error-prone.
First I needed to make sure that I'm inside a correct folder and then remember to invoke
`server` module from `http` library. So I looked for another approach in the files autogenerated
by pelican with quickstart procedure.

Since I've worked a bit with `invoke` package and used fabfiles in the past,
I immediately noticed `tasks.py` file in main directory of the project.
After skimming through the code, I found `build` and `serve` tasks which would enable me
to generate and serve output files without needing to think about platform/OS on which the tasks
would have to be run on. This sounded great as I'm using Windows whenever I can and resort to 
Linux virtual machine only if I have to suffer the performance hit.

To use this approach, I had to install `invoke` package:

.. code-block:: shell

    pipenv install invoke

After that, the procedure to run invoke tasks was wonderfully simple:

.. code-block:: shell

    pipenv run invoke build
    pipenv run invoke serve

Can we make it shorter? Sure! As this use case is probably one of the most frequently used
there is already a `reserve` task prepared and because typing `invoke` is such a hassle,
we can already use a shorthand `inv` to save the time needed to type `oke` at the end of it.

.. code-block:: shell

    pipenv run inv reserve

Works as expected. How great is that, huh?


Uploading the page to GitHub
****************************

After all that hassle, it would be great to finally share this page with others.
The creation process of a GitHub page is described in great detail in one of the official
guides titled `Getting Started with GitHub Pages`_ so I'll save some time and skip it.

Let's clone the remote repository in the main folder of our project:

.. code-block:: shell

    git init
    git remote add origin git@github.com:rotocki/rotocki.github.io.git
    git fetch --all
    git checkout origin/master -b master

After doing that, we should be able to commit our changes on top of whatever
we have autogenerated by GitHub during creation of the repository.

.. code-block:: shell

    git add .
    git commit -m "Initial page."
    git push

.. code-block:: shell

    git clone git@github.com:rotocki/rotocki.github.io.git



.. _File metadata: http://docs.getpelican.com/en/stable/content.html#file-metadata
.. _Getting Started with GitHub Pages: https://guides.github.com/features/pages/